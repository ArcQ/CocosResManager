{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/ResLoaderCtrl.js","src/ResLoaderView.js","src/ResManager.js","src/TextureDict.js","src/WebModel.js","src/iOSModel.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ResManager.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//LoadSceneCtrl serves as a replacement of the default preloader function (CCLoaderScene.js)\n//Scenes are used as controllers because running scenes have access to methods that the controller needs, this contradicts with MVC slightly\nvar WebModel = require('./WebModel');\nvar iOSModel = require('./iOSModel');\nvar ResLoaderView = require('./ResLoaderView');\nvar TextureDict = require('./TextureDict');\n\nvar ResLoaderCtrl = function(textureDict){\n    this.view = new ResLoaderView();\n    this.model = null ;\n    this.delayedCb = null;\n    this.isShowAnimation = null;\n    this.model = (cc.sys.os == \"iOS\") ? new iOSModel(): new WebModel();\n    this.model.textureDict = textureDict;\n};\n\nResLoaderCtrl.prototype.loadResources = function(key,resources,isShowAnimation,cb){\n    //native machines don't need preload function, show layer for a few seconds instead\n    console.log('loadResources');\n    this.isShowAnimation = isShowAnimation;\n    if(this.isShowAnimation === true){\n        console.log('this.isShowAnimation');\n        this.view.delayedCb = cb;\n        this.view.startUpdate.call(this.view);\n    }\n    else{\n        console.log('set this.delayedCb');\n        this.delayedCb = cb;\n    }\n\n    var self = this;\n    console.log(this.view.percentResLoaded);\n\n    //,this.resLoadUpdate,this.finishLoad\n    var self = this;\n    console.log(this.model.load);\n    console.log('model');\n    this.model.load.call(self.model,self,key,resources,self.resLoadUpdate,self.finishLoad);\n};\n\nResLoaderCtrl.prototype.resLoadUpdate = function(percentLoaded){\n    this.view.percentResLoaded = percentLoaded;\n};\n\nResLoaderCtrl.prototype.finishLoad= function(){\n            console.log('finish load');\n\n    if(this.isShowAnimation === true){\n        //delay the callback until after the loadingAnimation loads to 100 through update();\n        this.view.percentResLoaded = 100;\n\n    }\n    else{\n        console.log('call this.delayedCb');\n        this.delayedCb();\n    }\n};\n\n//built in cocos2d complete cache refresh, (incase of memory issues)\nResLoaderCtrl.prototype.removeAllTextures = function(){\n    cc.textureCache.removeAllTextures();\n};\n\n//refresh cache only for certain resource sets\nResLoaderCtrl.prototype.removeResTextures = function(resources){\n    this.model.removeResTextures(resources);\n};\n\n//refresh cache only for certain resource sets\nResLoaderCtrl.prototype.removeResTexturesByKey = function(key){\n    this.model.removeResTextures(key);\n};\n\nmodule.exports = ResLoaderCtrl;\n\n\n\n\n\n\n\n","//ResLoaderView is a scene that gets added\n//you can add customer layers to this making sure you pass a loading bar to this class\nvar ResLoaderView = cc.Scene.extend({\n    percentResLoaded:0,\n    percentBarLoaded:0,\n    loadingBar:null,\n    delayedCb:null,\n    onEnter: function () {\n        this._super();\n    },\n    update: function(dt){\n        this.setLoadingBarPercentage.call(this,dt);\n    }\n});\n\nResLoaderView.prototype.startUpdate = function(){\n    this.scheduleUpdate();\n};\n\nResLoaderView.prototype.skipLoad = function(cb){\n    this.scheduleOnce(\n        function(){\n            cb();\n        },\n        3.0,\n        \"key\"\n    );\n};\n\nResLoaderView.prototype.setLoadingBarPercentage = function(dt) {\n            console.log(this.percentBarLoaded);\n\n    if (this.percentBarLoaded < this.percentResLoaded){\n        this.percentBarLoaded = this.percentBarLoaded +dt/2*100;\n        this.loadingBar.setPercentage(this.percentBarLoaded);\n    }\n\n    if(this.percentBarLoaded >= 100){\n        this.unscheduleUpdate();\n        this.delayedCb();\n    }\n};\n\nmodule.exports = ResLoaderView;\n\n\n\n\n\n\n\n\n\n","var ResLoaderCtrl = require('./ResLoaderCtrl');\nvar TextureDict = require('./TextureDict.js'); \nvar ResManager = {\n    loaderCtrl:null,\n    textureDict:null,\n    loadedKeysArr:null\n};\n\n//private\nResManager.loadedKeysArr = [];\nResManager.textureDict = new TextureDict();\n\nResManager.loaderCtrl = new ResLoaderCtrl(ResManager.textureDict);\n\nResManager.addKey = function(key){\n    ResManager.loadedKeysArr[ResManager.loadedKeysArr.length] = key;\n};\n\nResManager.isKeyAdded = function(key){\n    for( var i = 0; i < ResManager.loadedKeysArr.length; i++ ) {\n        if (key == ResManager.loadedKeysArr[i]){\n            return true;\n        }\n    }\n    return false;\n};\n\n//public\n\n//ResLoader does not track what resources have been loaded or deleted, so avoid loading assets of the same name without removing it first\nResManager.loadResources = function(key,resources,isShowAnimation,cb){\n    if(!ResManager.isKeyAdded(key)){\n        ResManager.addKey(key,resources);\n        ResManager.loaderCtrl.loadResources(key,resources,isShowAnimation,cb);\n    }\n};\n\nResManager.resetTextureDict = function(){\n    ResMnager.textureDict.removeAllResources();\n    ResManger.textureDict = null;\n    ResManager.textureDict = new TextureDict();\n};\n\nwindow.ResManager = ResManager;\nmodule.exports = ResManager;\n","var TextureDict = function(){};\nTextureDict.prototype = new window.dLinkedList();\n//WebModel Only\nTextureDict.prototype.updateTextureDict = function(key,resources){\n    var listObj;\n    for(var i; i< resources.length;i++){\n        listObj = {name:resName,key:key,texture:texture};\n        this.push(listObj);\n    }\n}\n\nTextureDict.prototype.getTexture = function(resName){\n    var findByName = function(node){\n        return (node.obj.name == resName);\n    };\n    var node = this.findFirst(findByName);\n    return node.obj.texture;\n};\n\nTextureDict.prototype.removeResTextures = function(resources){\n    for(var i = 0; i < resources.length; i++){\n        var name = this.getNameFromResObj(resources[i])\n        this.removeResTextureByName(name);\n    }\n};\n\nTextureDict.prototype.removeResTexturesByName = function(name){\n    var findByName = function(node){\n        return (node.obj.name == resName);\n    };\n    var node = this.findFirst(findByName);\n    cc.TextureCache.getInstance().removeTexture(node.obj.texture);\n    this.remove(node);\n};\n\nTextureDict.prototype.getSprite = function(resStr){\n    console.log(resStr);\n    var name = this.getNameFromResObj(resStr);\n    var findByName = function(node){\n        //console.log(\"testOBJ\");\n        //console.log(node);\n        return (node.obj.name == name);\n    };\n    console.log(name);\n    console.log('this.findFirst');\n    console.log(this);\n    this.findFirst = this.findFirst.bind(this);\n    var node = this.findFirst(findByName);\n    return (cc.Sprite.createWithTexture(node.obj.texture));\n};\n\nTextureDict.prototype.removeAllResources = function(){\n    cc.TextureCache.getInstance().removeAllTextures();\n};\n\nTextureDict.prototype.getNameFromResObj = function(str){\n    if(str){\n        var resName;\n        var arr = str.split(\"/\");\n        arr = arr[arr.length-1].split(\".\");\n        return arr[0];\n    }\n    else{\n        console.log(\"Err: Res String cannot be undefined in getSprite()\");\n    }\n}\n\nmodule.exports = TextureDict;\n","var WebModel = cc.Scene.extend({\n    percentResLoaded:0,\n    delayedCb:null,\n    textureDict:null\n});\n\nWebModel.prototype.load = function(ctrl,key,resources,onUpdate,onFinish){\n    var model = this;\n    console.log('web loading');\n    cc.loader.load(\n        resources,  \n        //callback from actual loading process\n        function (result, count, loadedCount) {\n            var percentLoaded = (loadedCount / count * 100) | 0;\n            percentLoaded = Math.min(percentLoaded, 100);\n            onUpdate.call(ctrl,percentLoaded);\n        },\n        //tell ctrl resources are loaded\n        function () {\n            model.updateTextureDict(key,resources);\n            onFinish.call(ctrl);\n        }\n    );\n};\n\nWebModel.prototype.updateTextureDict = function(key,resources){\n    var listObj;\n    console.log(resources);\n    console.log(resources.length);\n    for(var i = 0; i< resources.length;i++){\n        console.log('texture');\n        console.log(cc);\n        var texture = cc.textureCache.textureForKey(resources[i]);\n        console.log(texture);\n        var resName = this.getNameFromResObj(resources[i]);\n        listObj = {name:resName,key:key,texture:texture};\n        console.log(listObj);\n        console.log('listObj');\n        this.textureDict.push(listObj);\n        console.log(this.textureDict.head);\n    }\n}\n\nWebModel.prototype.getTexture = function(resName){\n    var sprite = cc.Sprite.create(resName);\n    return sprite.getTexture();\n};\n\nWebModel.prototype.removeResTextures = function(resources){\n\n  for(var i = 0; i < resources.length; i++){\n      var texture = this.getTexture(resources[i]);\n      \n      cc.TextureCache.getInstance().removeTexture(texture);\n      \n      var findName = this.getNameFromResObj(resources[i]);\n      \n      var findCondition = function(node){\n        if(node.obj.name == findName){\n            return true;\n        }\n        return false;\n      };\n      \n      this.textureDict.findFirst()\n  }\n};\n\nWebModel.prototype.removeResTexturesByKey = function(key){\n    var findByKey = function(key){\n    return (node.obj.key == resName);\n  };\n\n  for(var i = 0; i < resources.length; i++){\n    var node = this.textureDict.findFirst(findByName);\n    cc.TextureCache.getInstance().removeTexture(node.obj.texture);\n  }\n};\n\nWebModel.prototype.getNameFromResObj = function(str){\n  var resName;\n  var arr = str.split(\"/\");\n  arr = arr[arr.length-1].split(\".\");\n  return arr[0];\n};\n\nmodule.exports = WebModel;\n\n\n\n\n\n\n\n\n","var iOSModel = function(){\n    this.percentResLoaded = 0;\n    this.delayedCb = 0;\n    this.currentTextureCache = [];\n    this.textureDict = null;\n};\n\niOSModel.prototype.load = function(ctrl,key,resources,onUpdate,onFinish){\n\n    for(var i = 0; i < resources.length; i++){\n        console.log('resources[i]' + resources[i]);\n        var resName = this.getNameFromResObj(resources[i]);\n        console.log(\"resName: \"+ resName);\n        var texture = cc.UIImageToTextureConverter.create(resName);     \n        var listObj = {name:resName,key:key,texture:texture};\n        this.textureDict.push(listObj);\n    }\n    onFinish.call(ctrl);\n\n};\n\niOSModel.prototype.getNameFromResObj = function(str){\n    var resName;\n    var arr = str.split(\"/\");\n    arr = arr[arr.length-1].split(\".\");\n    return arr[0];\n}\n\nmodule.exports = iOSModel;\n\n\n\n\n\n\n\n\n"]}