{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/ResLoaderCtrl.js","src/ResLoaderView.js","src/TextureDict.js","src/WebModel.js","src/iOSModel.js","src/resloader.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"resloader.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//LoadSceneCtrl serves as a replacement of the default preloader function (CCLoaderScene.js)\n//Scenes are used as controllers because running scenes have access to methods that the controller needs, this contradicts with MVC slightly\nvar WebModel = require('./WebModel');\nvar iOSModel = require('./iOSModel');\nvar ResLoaderView = require('./ResLoaderView');\nvar TextureDict = require('./TextureDict');\n\nvar ResLoaderCtrl = function(textureDict){\n    this.view = new ResLoaderView();\n    this.model = null ;\n    this.delayedCb = null;\n    this.isShowAnimation = null;\n    this.model = (cc.sys.os == \"iOS\") ? new iOSModel(): new WebModel();\n    this.model.textureDict = textureDict;\n};\n\nResLoaderCtrl.prototype.loadResources = function(key,resources,isShowAnimation,cb){\n    //native machines don't need preload function, show layer for a few seconds instead\n    console.log('loadResources');\n    this.isShowAnimation = isShowAnimation;\n    if(this.isShowAnimation === true){\n        console.log('this.isShowAnimation');\n        this.view.delayedCb = cb;\n        this.view.startUpdate.call(this.view);\n    }\n    else{\n        console.log('set this.delayedCb');\n        this.delayedCb = cb;\n    }\n\n    var self = this;\n    console.log(this.view.percentResLoaded);\n\n    //,this.resLoadUpdate,this.finishLoad\n    var self = this;\n    this.model.load.call(self.model,self,key,resources,self.resLoadUpdate,self.finishLoad);\n};\n\nResLoaderCtrl.prototype.resLoadUpdate = function(percentLoaded){\n    this.view.percentResLoaded = percentLoaded;\n};\n\nResLoaderCtrl.prototype.finishLoad= function(){\n            console.log('finish load');\n\n    if(this.isShowAnimation === true){\n        //delay the callback until after the loadingAnimation loads to 100 through update();\n        this.view.percentResLoaded = 100;\n\n    }\n    else{\n                console.log('call this.delayedCb');\n\n        this.delayedCb();\n    }\n};\n\n//built in cocos2d complete cache refresh, (incase of memory issues)\nResLoaderCtrl.prototype.removeAllTextures = function(){\n    cc.textureCache.removeAllTextures();\n};\n\n//refresh cache only for certain resource sets\nResLoaderCtrl.prototype.removeResTextures = function(resources){\n    this.model.removeResTextures(resources);\n};\n\n//refresh cache only for certain resource sets\nResLoaderCtrl.prototype.removeResTexturesByKey = function(key){\n    this.model.removeResTextures(key);\n};\n\nmodule.exports = ResLoaderCtrl;\n\n\n\n\n\n\n\n","//ResLoaderView is a scene that gets added\n//you can add customer layers to this making sure you pass a loading bar to this class\nvar ResLoaderView = cc.Scene.extend({\n    percentResLoaded:0,\n    percentBarLoaded:0,\n    loadingBar:null,\n    delayedCb:null,\n    onEnter: function () {\n        this._super();\n    },\n    update: function(dt){\n        this.setLoadingBarPercentage.call(this,dt);\n    }\n});\n\nResLoaderView.prototype.startUpdate = function(){\n    this.scheduleUpdate();\n};\n\nResLoaderView.prototype.skipLoad = function(cb){\n    this.scheduleOnce(\n        function(){\n            cb();\n        },\n        3.0,\n        \"key\"\n    );\n};\n\nResLoaderView.prototype.setLoadingBarPercentage = function(dt) {\n            console.log(this.percentBarLoaded);\n\n    if (this.percentBarLoaded < this.percentResLoaded){\n        this.percentBarLoaded = this.percentBarLoaded +dt/2*100;\n        this.loadingBar.setPercentage(this.percentBarLoaded);\n    }\n\n    if(this.percentBarLoaded >= 100){\n        this.unscheduleUpdate();\n        this.delayedCb();\n    }\n};\n\nmodule.exports = ResLoaderView;\n\n\n\n\n\n\n\n\n\n","var WebModel = require('./WebModel')\nvar textureDict = new window.dLinkedList();\n\nWebModel.prototype.updateTextureDict = function(key,resources){\n    var listObj;\n    for(var i; i< resources.length;i++){\n        listObj = {name:resName,key:key,texture:texture};\n        this.textureDict.push(listObj);\n    }\n}\n\nmodule.exports = textureDict;\n","//LoadSceneCtrl serves as a replacement of the default preloader function (CCLoaderScene.js)\n//Scenes are used as controllers because running scenes have access to methods that the controller needs, this contradicts with MVC slightly\nvar WebModel = cc.Scene.extend({\n    percentResLoaded:0,\n    delayedCb:null,\n    textureDict:null\n});\n\nWebModel.prototype.load = function(ctrl,key,resources,onUpdate,onFinish){\n    var model = this;\n    cc.loader.load(\n        resources,  \n        //callback from actual loading process\n        function (result, count, loadedCount) {\n            var percentLoaded = (loadedCount / count * 100) | 0;\n            percentLoaded = Math.min(percentLoaded, 100);\n            onUpdate.call(ctrl,percentLoaded);\n        },\n        //tell ctrl resources are loaded\n        function () {\n            model.updateTextureDict(key,resources);\n            onFinish.call(ctrl);\n        }\n    );\n};\n\nWebModel.prototype.updateTextureDict = function(key,resources){\n    var listObj;\n    for(var i; i< resources.length;i++){\n        listObj = {name:resName,key:key,texture:texture};\n        this.textureDict.push(listObj);\n    }\n}\n\nWebModel.prototype.getTexture = function(resName){\n    var sprite = cc.Sprite.create(resName);\n    return sprite.getTexture();\n};\n\nWebModel.prototype.removeResTextures = function(resources){\n\n  for(var i = 0; i < resources.length; i++){\n      var texture = this.getTexture(resources[i]);\n      \n      cc.textureCache.removeTexture(texture);\n      \n      var findName = this.getNameFromResObj(resources[i]);\n      \n      var findCondition = function(node){\n        if(node.obj.name == findName){\n            return true;\n        }\n        return false;\n      };\n      \n      this.textureDict.findFirst()\n  }\n};\n\nWebModel.prototype.removeResTexturesByKey = function(key){\n    var findByKey = function(key){\n    return (node.obj.key == resName);\n  };\n\n  for(var i = 0; i < resources.length; i++){\n    var node = this.textureDict.findFirst(findByName);\n    cc.textureCache.removeTexture(node.obj.texture);\n  }\n};\n\nWebModel.prototype.getNameFromResObj = function(str){\n  var resName;\n  var arr = str.split(\"/\");\n  arr = arr[arr.length-1].split(\".\");\n  return arr[0];\n};\n\nmodule.exports = WebModel;\n\n\n\n\n\n\n\n\n","//LoadSceneCtrl serves as a replacement of the default preloader function (CCLoaderScene.js)\n//Scenes are used as controllers because running scenes have access to methods that the controller needs, this contradicts with MVC slightly\n\nvar iOSModel = function(){\n\tthis.percentResLoaded = 0;\n\tthis.delayedCb = 0;\n\tthis.currentTextureCache = [];\n\tthis.textureDict = null;\n};\n\n\niOSModel.prototype.load = function(ctrl,key,resources,onUpdate,onFinish){\n\n  for(var i = 0; i < resources.length; i++){\n    console.log('resources[i]' + resources[i]);\n  \t  var resName = this.getNameFromResObj(resources[i]);\n      console.log(\"resName: \"+ resName);\n      var texture = cc.UIImageToTextureConverter.create(resName);     \n      var listObj = {name:resName,key:key,texture:texture};\n      this.textureDict.push(listObj);\n  }\n  onFinish.call(ctrl);\n\n};\n\niOSModel.prototype.getTexture = function(resName){\n  var findByName = function(node){\n    return (node.obj.name == resName);\n  };\n  var node = this.textureDict.findFirst(findByName);\n  return node.obj.texture;\n};\n\niOSModel.prototype.removeResTextures = function(resources){\n\n  for(var i = 0; i < resources.length; i++){\n      var texture = this.getTexture(resources[i]);\n      cc.textureCache.removeTexture(texture);\n  }\n};\n\niOSModel.prototype.removeResTexturesByKey = function(key){\n\tvar findByKey = function(key){\n    return (node.obj.key == resName);\n  };\n\n  for(var i = 0; i < resources.length; i++){\n    var node = this.textureDict.findFirst(findByName);\n    cc.textureCache.removeTexture(node.obj.texture);\n  }\n};\n\niOSModel.prototype.getNameFromResObj = function(str){\n  var resName;\n  var arr = str.split(\"/\");\n  arr = arr[arr.length-1].split(\".\");\n  return arr[0];\n}\n\nmodule.exports = iOSModel;\n\n\n\n\n\n\n\n\n","//LoadSceneCtrl serves as a replacement of the default preloader function (CCLoaderScene.js)\n//Scenes are used as controllers because running scenes have access to methods that the controller needs, this contradicts with MVC slightly\nvar ResLoaderCtrl = require('./ResLoaderCtrl');\n\nvar ResManager = {\n    ctrl:null,\n    textureDict:null,\n    loadedKeysArr:null\n};\n\n//private\nResManager.loadedKeysArr = [];\nResManager.textureDict = new window.dLinkedList();\n\nResManager.ctrl = new ResLoaderCtrl(ResLoader.textureDict);\n\nResManager.addKey = function(key){\n    ResManager.loadedKeysArr[ResManager.loadedKeysArr.length] = key;\n};\n\nResManager.isKeyAdded = function(key){\n    for( var i = 0; i < ResLoader.loadedKeysArr.length; i++ ) {\n        if (key == ResLoader.loadedKeysArr[i]){\n            return true;\n        }\n    }\n    return false;\n};\n\n//public\n\n//ResLoader does not track what resources have been loaded or deleted, so avoid loading assets of the same name without removing it first\nResManager.loadResources = function(key,resources,isShowAnimation,cb){\n    if(!ResManager.isKeyAdded(key)){\n        ResManager.addKey(key,resources);\n        ResManager.ctrl.loadResources(key,resources,isShowAnimation,cb);\n    }\n};\n\nResManager.getTexture = function(res){\n    ResLoader.ctrl.getTexture(res);\n    return ResManager.textureDict(res);\n};\n\nResManager.removeAllResources = function(cb){\n    cc.textureCache.removeAllTextures();\n    if(cb != null){\n        cb();\n    }\n    ResManager.loadedKeysArr = [];\n};\n\n//not yet implemented\nResManager.removeResourcesByKey = function(key,cb){\n    ResLoader.addKey(key);\n    if(cb != null){\n        cb();\n    };\n\n};\n\nwindow.ResLoader = ResLoader;\n\nmodule.exports = ResLoader;\n\n\n\n\n\n\n\n"]}